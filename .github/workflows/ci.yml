name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  skill-format:
    name: Skill Format Validation
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Verify infrastructure directories
        run: |
          echo "Verifying project structure..."
          test -d canonical/agents || { echo "Missing canonical/agents/"; exit 1; }
          test -d canonical/councils || { echo "Missing canonical/councils/"; exit 1; }
          test -d canonical/templates || { echo "Missing canonical/templates/"; exit 1; }
          test -d skills || { echo "Missing skills/"; exit 1; }
          test -d scripts || { echo "Missing scripts/"; exit 1; }
          test -f scripts/build.sh || { echo "Missing scripts/build.sh"; exit 1; }
          test -f scripts/skill-manifest.json || { echo "Missing scripts/skill-manifest.json"; exit 1; }
          echo "Infrastructure verified!"

      - name: Validate SKILL.md frontmatter
        run: |
          errors=0
          for dir in skills/*/; do
            skill_name=$(basename "$dir")
            skill_file="${dir}SKILL.md"

            if [ ! -f "$skill_file" ]; then
              echo "ERROR: Missing SKILL.md in ${dir}"
              errors=$((errors + 1))
              continue
            fi

            # Check for name in frontmatter
            if ! head -20 "$skill_file" | grep -q "^name:"; then
              echo "ERROR: ${skill_file} missing 'name' in frontmatter"
              errors=$((errors + 1))
            fi

            # Check for description in frontmatter
            if ! head -20 "$skill_file" | grep -q "^description:"; then
              echo "ERROR: ${skill_file} missing 'description' in frontmatter"
              errors=$((errors + 1))
            fi

            # Check that name matches directory
            fm_name=$(head -20 "$skill_file" | grep "^name:" | head -1 | sed 's/^name: *//')
            if [ "$fm_name" != "$skill_name" ]; then
              echo "ERROR: ${skill_file} name '${fm_name}' does not match directory '${skill_name}'"
              errors=$((errors + 1))
            fi
          done

          if [ $errors -gt 0 ]; then
            echo "${errors} format error(s) found"
            exit 1
          fi
          echo "All skill formats valid!"

  self-containment:
    name: Self-Containment Check
    runs-on: ubuntu-latest
    needs: skill-format
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Set up Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5
        with:
          python-version: '3.x'

      - name: Verify build script produces no drift
        run: |
          chmod +x scripts/build.sh
          scripts/build.sh --check

      - name: Verify each skill has required resources
        run: |
          errors=0
          for dir in skills/*/; do
            skill_name=$(basename "$dir")

            # Skip internal/stub skills (Phase 2 skills not yet genericized)
            skill_md="${dir}SKILL.md"
            if [ -f "$skill_md" ] && grep -q 'internal: true' "$skill_md" 2>/dev/null; then
              echo "SKIP: ${skill_name} (internal stub)"
              continue
            fi

            # Every skill must have at least one agent
            if [ ! -d "${dir}agents" ] || [ -z "$(ls "${dir}agents/" 2>/dev/null)" ]; then
              echo "ERROR: ${skill_name} has no agents directory or it is empty"
              errors=$((errors + 1))
            fi

            # Every skill must have at least one council
            if [ ! -d "${dir}councils" ] || [ -z "$(ls "${dir}councils/" 2>/dev/null)" ]; then
              echo "ERROR: ${skill_name} has no councils directory or it is empty"
              errors=$((errors + 1))
            fi
          done

          if [ $errors -gt 0 ]; then
            echo "${errors} self-containment error(s) found"
            exit 1
          fi
          echo "All skills are self-contained!"

  leakage-scan:
    name: Tech-Stack Leakage Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Scan skills/ for tech-stack references
        run: |
          # Deny-list of technology-specific terms that should not appear in
          # universal skills. These are checked case-insensitively.
          DENY_LIST="React|Vue|Angular|Svelte|Next\.js|Nuxt|Tailwind|shadcn"
          DENY_LIST="${DENY_LIST}|NestJS|Express|Fastify|Django|Rails|Flask|Spring"
          DENY_LIST="${DENY_LIST}|Prisma|TypeORM|Drizzle|Sequelize|Mongoose"
          DENY_LIST="${DENY_LIST}|PostgreSQL|MySQL|MongoDB|SQLite|Redis"
          DENY_LIST="${DENY_LIST}|tRPC|GraphQL"
          DENY_LIST="${DENY_LIST}|Vite|Webpack|Turborepo|Rollup|esbuild"
          DENY_LIST="${DENY_LIST}|pnpm|yarn|bun|Lerna|Nx"
          DENY_LIST="${DENY_LIST}|Vitest|Jest|Playwright|Cypress|Mocha"
          DENY_LIST="${DENY_LIST}|Zod|Joi|Yup"

          errors=0
          while IFS= read -r file; do
            [ -n "$file" ] || continue
            matches=$(grep -inE "$DENY_LIST" "$file" 2>/dev/null || true)
            if [ -n "$matches" ]; then
              echo "LEAKAGE in ${file}:"
              echo "$matches"
              echo ""
              errors=$((errors + 1))
            fi
          done < <(find skills/ -maxdepth 2 -name "SKILL.md")

          if [ $errors -gt 0 ]; then
            echo ""
            echo "${errors} file(s) contain tech-stack references"
            echo ""
            echo "Skills must be technology-agnostic. Replace specific tool names"
            echo "with generic descriptions (e.g., 'your test runner' instead of 'Jest')."
            # Advisory only — existing skills are being genericized incrementally
          else
            echo "No tech-stack leakage detected!"
          fi

  community-safety:
    name: Community Safety Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Check for personal paths
        run: |
          errors=0
          while IFS= read -r file; do
            [ -n "$file" ] || continue
            matches=$(grep -nE "/Users/|/home/|/root/|C:\\\\|C:/|/mnt/c/|/mnt/wsl/" "$file" 2>/dev/null || true)
            if [ -n "$matches" ]; then
              echo "PERSONAL PATH in ${file}:"
              echo "$matches"
              errors=$((errors + 1))
            fi
          done < <(find . -type f \( -name "*.md" -o -name "*.json" -o -name "*.yml" -o -name "*.yaml" -o -name "*.sh" \) | grep -v node_modules | grep -v '.git/' | grep -v '.github/workflows/')

          if [ $errors -gt 0 ]; then
            echo "${errors} file(s) contain personal paths"
            exit 1
          fi
          echo "No personal paths found!"

      - name: Check for local settings tracked
        run: |
          if git ls-files --error-unmatch .claude/settings.local.json 2>/dev/null; then
            echo "ERROR: .claude/settings.local.json is tracked in git"
            echo "This file contains machine-specific settings and should be in .gitignore"
            exit 1
          fi
          echo "No local settings tracked!"

      - name: Verify LICENSE exists
        run: |
          if [ ! -f LICENSE ] && [ ! -f LICENSE.md ] && [ ! -f LICENSE.txt ]; then
            echo "WARNING: No LICENSE file found"
            echo "A LICENSE file is required for open-source distribution"
            exit 1
          fi
          echo "LICENSE file exists!"

  broken-links:
    name: Broken Link Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Check relative markdown links
        run: |
          errors=0
          while IFS= read -r file; do
            [ -n "$file" ] || continue
            dir=$(dirname "$file")

            # Extract relative markdown links: [text](path) — skip URLs and anchors
            links=$(grep -oE '\[([^]]*)\]\(([^)]+)\)' "$file" 2>/dev/null | \
              grep -oE '\(([^)]+)\)' | \
              sed 's/^(//;s/)$//' | \
              grep -v '^http' | \
              grep -v '^#' | \
              grep -v '^mailto:' | \
              sed 's/#.*//' || true)

            for link in $links; do
              # Resolve relative to the file's directory
              if [ -n "$link" ]; then
                # Skip template placeholders (e.g., NNN-slug.md, <number>)
                case "$link" in
                  *NNN*|*'<'*) continue ;;
                esac
                resolved="${dir}/${link}"
                if [ ! -e "$resolved" ]; then
                  echo "BROKEN LINK in ${file}: ${link}"
                  errors=$((errors + 1))
                fi
              fi
            done
          done < <(find . -type f -name "*.md" | grep -v node_modules | grep -v '.git/')

          if [ $errors -gt 0 ]; then
            echo ""
            echo "${errors} broken link(s) found"
            exit 1
          fi
          echo "All relative links resolve!"

  markdown-lint:
    name: Markdown Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Check YAML frontmatter on documentation files
        run: |
          warnings=0
          # Check root documentation files and docs/ directory
          for file in README.md CONTRIBUTING.md CHANGELOG.md docs/*.md; do
            [ -f "$file" ] || continue

            # Check if file starts with ---
            first_line=$(head -1 "$file")
            if [ "$first_line" != "---" ]; then
              echo "WARNING: ${file} missing YAML frontmatter"
              warnings=$((warnings + 1))
            fi
          done

          if [ $warnings -gt 0 ]; then
            echo ""
            echo "${warnings} file(s) missing frontmatter (advisory)"
            # Advisory only — don't fail the build
          else
            echo "All documentation files have frontmatter!"
          fi

      - name: Check for common markdown issues
        run: |
          warnings=0
          while IFS= read -r file; do
            [ -n "$file" ] || continue

            # Check for trailing whitespace (POSIX-compatible grep)
            if grep -qE '[^[:space:]][[:space:]]+$' "$file" 2>/dev/null; then
              echo "WARNING: ${file} has trailing whitespace"
              warnings=$((warnings + 1))
            fi

            # Check for consecutive blank lines (more than 2)
            if awk '/^$/{n++; if(n>2){found=1}} /[^ ]/{n=0} END{exit !found}' "$file" 2>/dev/null; then
              echo "WARNING: ${file} has excessive blank lines"
              warnings=$((warnings + 1))
            fi
          done < <(find . -type f -name "*.md" | grep -v node_modules | grep -v '.git/')

          if [ $warnings -gt 0 ]; then
            echo ""
            echo "${warnings} markdown issue(s) found (advisory)"
            # Advisory only — don't fail the build
          else
            echo "Markdown quality looks good!"
          fi
